\hypertarget{classArgParser_1_1ParserBase}{}\doxysection{Arg\+Parser.\+Parser\+Base Class Reference}
\label{classArgParser_1_1ParserBase}\index{ArgParser.ParserBase@{ArgParser.ParserBase}}


To specify options/arguments Inherit from this class and declare Option / Argument fields that are descendants of \mbox{\hyperlink{classArgParser_1_1ArgumentBase}{Argument\+Base}} / \mbox{\hyperlink{}{Option\+Base}} After the \mbox{\hyperlink{classArgParser_1_1ParserBase_aee3c7c8164300c12d22eba3f43b18448}{Parse}} method is called, parsed results could be obtained using field\+Name.\+Get\+Value()  


\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{classArgParser_1_1ParserBase_aee3c7c8164300c12d22eba3f43b18448}{Parse}} (string\mbox{[}$\,$\mbox{]} args)
\begin{DoxyCompactList}\small\item\em Parses args and stores parsed values in declared fields. \end{DoxyCompactList}\item 
string \mbox{\hyperlink{classArgParser_1_1ParserBase_aba7b31391e6fef089ee0d640d323756d}{Generate\+Help}} ()
\begin{DoxyCompactList}\small\item\em Automatically generates help message from declared fields (name, description). \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual \mbox{\hyperlink{interfaceArgParser_1_1IArgument}{IArgument}}\mbox{[}$\,$\mbox{]} \mbox{\hyperlink{classArgParser_1_1ParserBase_a05609e87376d6f124142ff14699a1885}{Get\+Argument\+Order}} ()
\begin{DoxyCompactList}\small\item\em Used by the parser to determine order of arguments. Since reflection doesn\textquotesingle{}t necessarily retain the order of fields, it needs to be specified by the user. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Properties}
\begin{DoxyCompactItemize}
\item 
virtual string \mbox{\hyperlink{classArgParser_1_1ParserBase_af32109fa88060e503c9945f4ca9d9991}{Delimiter}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em A command-\/line argument consisting of two dashes only, default\+: \char`\"{}-\/-\/\char`\"{}. Any subsequent argument is considered to be a plain argument \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
To specify options/arguments Inherit from this class and declare Option / Argument fields that are descendants of \mbox{\hyperlink{classArgParser_1_1ArgumentBase}{Argument\+Base}} / \mbox{\hyperlink{}{Option\+Base}} After the \mbox{\hyperlink{classArgParser_1_1ParserBase_aee3c7c8164300c12d22eba3f43b18448}{Parse}} method is called, parsed results could be obtained using field\+Name.\+Get\+Value() 

Definition at line \mbox{\hyperlink{ParserBase_8cs_source_l00015}{15}} of file \mbox{\hyperlink{ParserBase_8cs_source}{Parser\+Base.\+cs}}.



\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classArgParser_1_1ParserBase_a9f3ed90265bc2ab6a488d9ab6be0f292}\label{classArgParser_1_1ParserBase_a9f3ed90265bc2ab6a488d9ab6be0f292}} 
\index{ArgParser.ParserBase@{ArgParser.ParserBase}!ParserBase@{ParserBase}}
\index{ParserBase@{ParserBase}!ArgParser.ParserBase@{ArgParser.ParserBase}}
\doxysubsubsection{\texorpdfstring{ParserBase()}{ParserBase()}}
{\footnotesize\ttfamily Arg\+Parser.\+Parser\+Base.\+Parser\+Base (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}



Definition at line \mbox{\hyperlink{ParserBase_8cs_source_l00019}{19}} of file \mbox{\hyperlink{ParserBase_8cs_source}{Parser\+Base.\+cs}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00020         \{}
\DoxyCodeLine{00021             \textcolor{keywordtype}{void} AssignOptions() }
\DoxyCodeLine{00022             \{}
\DoxyCodeLine{00023                 var fields = GetType().GetFields();}
\DoxyCodeLine{00024                 \textcolor{keywordflow}{foreach} (var field \textcolor{keywordflow}{in} fields)}
\DoxyCodeLine{00025                 \{}
\DoxyCodeLine{00026                     \textcolor{keywordflow}{if} (field.FieldType.GetInterface(nameof(IOption)) != \textcolor{keyword}{null})}
\DoxyCodeLine{00027                     \{}
\DoxyCodeLine{00028                         options.Add((IOption)(field.GetValue(\textcolor{keyword}{this}))!);}
\DoxyCodeLine{00029                     \}}
\DoxyCodeLine{00030                 \}}
\DoxyCodeLine{00031             \}}
\DoxyCodeLine{00032 }
\DoxyCodeLine{00033             \textcolor{keywordtype}{void} CheckConflictingAliases() }
\DoxyCodeLine{00034             \{}
\DoxyCodeLine{00035                 HashSet<string> aliases = \textcolor{keyword}{new}();}
\DoxyCodeLine{00036 }
\DoxyCodeLine{00037                 \textcolor{keywordflow}{foreach} (var opt \textcolor{keywordflow}{in} options)}
\DoxyCodeLine{00038                 \{}
\DoxyCodeLine{00039                     \textcolor{keywordflow}{foreach} (var name \textcolor{keywordflow}{in} opt.Names)}
\DoxyCodeLine{00040                     \{}
\DoxyCodeLine{00041                         \textcolor{keywordflow}{if} (!aliases.Contains(name))}
\DoxyCodeLine{00042                             aliases.Add(name);}
\DoxyCodeLine{00043                         \textcolor{keywordflow}{else}}
\DoxyCodeLine{00044                             \textcolor{keywordflow}{throw} \textcolor{keyword}{new} ParserCodeException(\textcolor{stringliteral}{"{}Parameter aliases are in conflict."{}});}
\DoxyCodeLine{00045                     \}}
\DoxyCodeLine{00046                 \}}
\DoxyCodeLine{00047             \}}
\DoxyCodeLine{00048 }
\DoxyCodeLine{00049             \textcolor{keywordtype}{void} CheckUnknownPlainArguments() }
\DoxyCodeLine{00050             \{}
\DoxyCodeLine{00051                 var orderedPlainArgs = \mbox{\hyperlink{classArgParser_1_1ParserBase_a05609e87376d6f124142ff14699a1885}{GetArgumentOrder}}();}
\DoxyCodeLine{00052                 var classPlainArgs = GetType().GetFields()}
\DoxyCodeLine{00053                     .Where(field => field.FieldType.GetInterface(nameof(IArgument)) != \textcolor{keyword}{null})}
\DoxyCodeLine{00054                     .Select(field => (IArgument)(field.GetValue(\textcolor{keyword}{this}))!);}
\DoxyCodeLine{00055 }
\DoxyCodeLine{00056                 var orderedPlainArgsSet = orderedPlainArgs.ToHashSet();}
\DoxyCodeLine{00057                 var classPlainArgsSet = classPlainArgs.ToHashSet();}
\DoxyCodeLine{00058 }
\DoxyCodeLine{00059                 \textcolor{keywordflow}{if} (orderedPlainArgs.Length != orderedPlainArgsSet.Count)}
\DoxyCodeLine{00060                     \textcolor{keywordflow}{throw} \textcolor{keyword}{new} ParserCodeException(\textcolor{stringliteral}{"{}Duplicate elements in argument order specification"{}});}
\DoxyCodeLine{00061 }
\DoxyCodeLine{00062 }
\DoxyCodeLine{00063                 \textcolor{keywordflow}{foreach} (var pa \textcolor{keywordflow}{in} orderedPlainArgsSet)}
\DoxyCodeLine{00064                 \{}
\DoxyCodeLine{00065                     \textcolor{keywordflow}{if} (!classPlainArgsSet.Contains(pa))}
\DoxyCodeLine{00066                         \textcolor{keywordflow}{throw} \textcolor{keyword}{new} ParserCodeException(\textcolor{stringliteral}{"{}Unused plain arguments out of argument order"{}});}
\DoxyCodeLine{00067                 \}}
\DoxyCodeLine{00068 }
\DoxyCodeLine{00069                 \textcolor{keywordflow}{foreach} (var pa \textcolor{keywordflow}{in} classPlainArgsSet)}
\DoxyCodeLine{00070                 \{}
\DoxyCodeLine{00071                     \textcolor{keywordflow}{if} (!orderedPlainArgsSet.Contains(pa))}
\DoxyCodeLine{00072                         \textcolor{keywordflow}{throw} \textcolor{keyword}{new} ParserCodeException(\textcolor{stringliteral}{"{}Unknown plain arguments in argument order ( didn't you forget to override it? :) )"{}});}
\DoxyCodeLine{00073                 \}}
\DoxyCodeLine{00074             \}}
\DoxyCodeLine{00075 }
\DoxyCodeLine{00076             \textcolor{keywordtype}{void} CheckMultipleVariadicPlainArgs() }
\DoxyCodeLine{00077             \{}
\DoxyCodeLine{00078                 \textcolor{keywordflow}{if} (\mbox{\hyperlink{classArgParser_1_1ParserBase_a05609e87376d6f124142ff14699a1885}{GetArgumentOrder}}().Where(argument => argument.ParameterAccept.IsVariadic).Count() > 1)}
\DoxyCodeLine{00079                     \textcolor{keywordflow}{throw} \textcolor{keyword}{new} ParserCodeException(\textcolor{stringliteral}{"{}Multiple plain arguments with variadic count"{}});}
\DoxyCodeLine{00080             \}}
\DoxyCodeLine{00081 }
\DoxyCodeLine{00082             AssignOptions();}
\DoxyCodeLine{00083             CheckConflictingAliases();}
\DoxyCodeLine{00084             CheckUnknownPlainArguments();}
\DoxyCodeLine{00085             CheckMultipleVariadicPlainArgs();}
\DoxyCodeLine{00086         \}}

\end{DoxyCode}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classArgParser_1_1ParserBase_aba7b31391e6fef089ee0d640d323756d}\label{classArgParser_1_1ParserBase_aba7b31391e6fef089ee0d640d323756d}} 
\index{ArgParser.ParserBase@{ArgParser.ParserBase}!GenerateHelp@{GenerateHelp}}
\index{GenerateHelp@{GenerateHelp}!ArgParser.ParserBase@{ArgParser.ParserBase}}
\doxysubsubsection{\texorpdfstring{GenerateHelp()}{GenerateHelp()}}
{\footnotesize\ttfamily string Arg\+Parser.\+Parser\+Base.\+Generate\+Help (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Automatically generates help message from declared fields (name, description). 



Definition at line \mbox{\hyperlink{ParserBase_8cs_source_l00228}{228}} of file \mbox{\hyperlink{ParserBase_8cs_source}{Parser\+Base.\+cs}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00229         \{}
\DoxyCodeLine{00230             StringBuilder result = \textcolor{keyword}{new}();}
\DoxyCodeLine{00231 }
\DoxyCodeLine{00232             \textcolor{keywordtype}{string} GetArgumentName(IArgument argument) }
\DoxyCodeLine{00233             \{}
\DoxyCodeLine{00234                 \textcolor{keywordtype}{string} result = argument.Name;}
\DoxyCodeLine{00235 }
\DoxyCodeLine{00236                 \textcolor{keywordflow}{if} (argument.ParameterAccept.MaxParamAmount > 1)}
\DoxyCodeLine{00237                     result += \textcolor{stringliteral}{"{}..."{}};}
\DoxyCodeLine{00238                 \textcolor{keywordflow}{if} (argument.ParameterAccept.MinParamAmount == 0)}
\DoxyCodeLine{00239                     result = \$\textcolor{stringliteral}{"{}[\{result\}]"{}};}
\DoxyCodeLine{00240 }
\DoxyCodeLine{00241                 \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{00242             \}}
\DoxyCodeLine{00243 }
\DoxyCodeLine{00244             \textcolor{keywordtype}{void} AppendUsageExampleLine(StringBuilder result) }
\DoxyCodeLine{00245             \{}
\DoxyCodeLine{00246                 \textcolor{keywordtype}{string} programName = System.Diagnostics.Process.GetCurrentProcess().ProcessName;}
\DoxyCodeLine{00247                 result.Append(programName);}
\DoxyCodeLine{00248                 \textcolor{keywordflow}{if} (options.Count > 0) result.Append(\textcolor{stringliteral}{"{} [options]"{}});}
\DoxyCodeLine{00249                 \textcolor{keywordflow}{foreach} (var plainArg \textcolor{keywordflow}{in} \mbox{\hyperlink{classArgParser_1_1ParserBase_a05609e87376d6f124142ff14699a1885}{GetArgumentOrder}}())}
\DoxyCodeLine{00250                     result.Append(\$\textcolor{stringliteral}{"{} \{GetArgumentName(plainArg)\}"{}});}
\DoxyCodeLine{00251                 result.Append(\textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)n"{}});}
\DoxyCodeLine{00252             \}}
\DoxyCodeLine{00253 }
\DoxyCodeLine{00254             \textcolor{keywordtype}{void} AppendOptionHelp(StringBuilder result) }
\DoxyCodeLine{00255             \{}
\DoxyCodeLine{00256                 result.Append(\textcolor{stringliteral}{"{}Options:\(\backslash\)n"{}});}
\DoxyCodeLine{00257                 \textcolor{keywordflow}{foreach} (var opt \textcolor{keywordflow}{in} options)}
\DoxyCodeLine{00258                     result.Append(\$\textcolor{stringliteral}{"{}\{opt.GetHelp()\}"{}});}
\DoxyCodeLine{00259             \}}
\DoxyCodeLine{00260 }
\DoxyCodeLine{00261             \textcolor{keywordtype}{void} AppendPlainArgHelp(StringBuilder result) }
\DoxyCodeLine{00262             \{}
\DoxyCodeLine{00263                 result.Append(\textcolor{stringliteral}{"{}Arguments:\(\backslash\)n"{}});}
\DoxyCodeLine{00264                 \textcolor{keywordflow}{foreach} (var plainArg \textcolor{keywordflow}{in} \mbox{\hyperlink{classArgParser_1_1ParserBase_a05609e87376d6f124142ff14699a1885}{GetArgumentOrder}}())}
\DoxyCodeLine{00265                     result.Append(plainArg.GetHelp());}
\DoxyCodeLine{00266             \}}
\DoxyCodeLine{00267 }
\DoxyCodeLine{00268             AppendUsageExampleLine(result);}
\DoxyCodeLine{00269             AppendOptionHelp(result);}
\DoxyCodeLine{00270             AppendPlainArgHelp(result);}
\DoxyCodeLine{00271 }
\DoxyCodeLine{00272             \textcolor{keywordflow}{return} result.ToString();}
\DoxyCodeLine{00273         \}}

\end{DoxyCode}
\mbox{\Hypertarget{classArgParser_1_1ParserBase_a05609e87376d6f124142ff14699a1885}\label{classArgParser_1_1ParserBase_a05609e87376d6f124142ff14699a1885}} 
\index{ArgParser.ParserBase@{ArgParser.ParserBase}!GetArgumentOrder@{GetArgumentOrder}}
\index{GetArgumentOrder@{GetArgumentOrder}!ArgParser.ParserBase@{ArgParser.ParserBase}}
\doxysubsubsection{\texorpdfstring{GetArgumentOrder()}{GetArgumentOrder()}}
{\footnotesize\ttfamily virtual \mbox{\hyperlink{interfaceArgParser_1_1IArgument}{IArgument}}\mbox{[}$\,$\mbox{]} Arg\+Parser.\+Parser\+Base.\+Get\+Argument\+Order (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}



Used by the parser to determine order of arguments. Since reflection doesn\textquotesingle{}t necessarily retain the order of fields, it needs to be specified by the user. 

\begin{DoxyReturn}{Returns}
References to argument fields
\end{DoxyReturn}
\mbox{\Hypertarget{classArgParser_1_1ParserBase_aee3c7c8164300c12d22eba3f43b18448}\label{classArgParser_1_1ParserBase_aee3c7c8164300c12d22eba3f43b18448}} 
\index{ArgParser.ParserBase@{ArgParser.ParserBase}!Parse@{Parse}}
\index{Parse@{Parse}!ArgParser.ParserBase@{ArgParser.ParserBase}}
\doxysubsubsection{\texorpdfstring{Parse()}{Parse()}}
{\footnotesize\ttfamily void Arg\+Parser.\+Parser\+Base.\+Parse (\begin{DoxyParamCaption}\item[{string\mbox{[}$\,$\mbox{]}}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Parses args and stores parsed values in declared fields. 


\begin{DoxyParams}{Parameters}
{\em args} & Arguments to parse\\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em \mbox{\hyperlink{classArgParser_1_1ParserCodeException}{Parser\+Code\+Exception}}} & Thrown when the class doesn\textquotesingle{}t conform to the parser requirements\\
\hline
{\em \mbox{\hyperlink{classArgParser_1_1ParseException}{Parse\+Exception}}} & Thrown when parsed arguments don\textquotesingle{}t satisfy declared option fields\+: Fields not inheriting from predefined classes (descendants of {\ttfamily \mbox{\hyperlink{classArgParser_1_1OptionBase}{Option\+Base}}\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}} or {\ttfamily \mbox{\hyperlink{classArgParser_1_1ArgumentBase}{Argument\+Base}}\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}}) Defining argument fields without overriding {\ttfamily Get\+Argument\+Order}\\
\hline
\end{DoxyExceptions}
Returns value between option.\+Parameter\+Accept.\+Min\+Param\+Amount and option.\+Parameter\+Accept.\+Max\+Param\+Amount. Consume as much params as possible if variadic. 

Definition at line \mbox{\hyperlink{ParserBase_8cs_source_l00109}{109}} of file \mbox{\hyperlink{ParserBase_8cs_source}{Parser\+Base.\+cs}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00110         \{}
\DoxyCodeLine{00111             IOption? TryGetOption(\textcolor{keywordtype}{string} name) => options.Find(o => o.MatchingOptionName(name));}
\DoxyCodeLine{00112 }
\DoxyCodeLine{00117             \textcolor{keywordtype}{int} GetOptionParamCount(IOption option, \textcolor{keywordtype}{string}[] args, \textcolor{keywordtype}{int} argIdx) }
\DoxyCodeLine{00118             \{}
\DoxyCodeLine{00119                 \textcolor{keywordtype}{int} result = 0;}
\DoxyCodeLine{00120                 \textcolor{keywordflow}{while} (result < option.ParameterAccept.MaxParamAmount)}
\DoxyCodeLine{00121                 \{}
\DoxyCodeLine{00122                     \textcolor{keywordtype}{int} idx = argIdx + result + 1;}
\DoxyCodeLine{00123                     \textcolor{keywordflow}{if} (idx == args.Length || args[idx] == \mbox{\hyperlink{classArgParser_1_1ParserBase_af32109fa88060e503c9945f4ca9d9991}{Delimiter}} || TryGetOption(args[idx]) != \textcolor{keyword}{null})}
\DoxyCodeLine{00124                     \{}
\DoxyCodeLine{00125                         \textcolor{keywordflow}{if} (result < option.ParameterAccept.MinParamAmount) \textcolor{keywordflow}{throw} \textcolor{keyword}{new} ParseException(\textcolor{stringliteral}{"{}Too few parameters passed to option"{}});}
\DoxyCodeLine{00126                         \textcolor{keywordflow}{else} \textcolor{keywordflow}{break};}
\DoxyCodeLine{00127                     \}}
\DoxyCodeLine{00128                     result++;}
\DoxyCodeLine{00129                 \}}
\DoxyCodeLine{00130                 \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{00131             \}}
\DoxyCodeLine{00132 }
\DoxyCodeLine{00136             \textcolor{keywordtype}{int} ParseOptions(\textcolor{keywordtype}{string}[] args) }
\DoxyCodeLine{00137             \{}
\DoxyCodeLine{00138                 \textcolor{keywordtype}{bool} IsPlainArg(\textcolor{keywordtype}{string} arg) => !arg.StartsWith(\textcolor{stringliteral}{"{}-\/"{}});}
\DoxyCodeLine{00139 }
\DoxyCodeLine{00140                 \textcolor{keywordtype}{int} argIdx = 0;}
\DoxyCodeLine{00141                 \textcolor{keywordflow}{while} (argIdx < args.Length)}
\DoxyCodeLine{00142                 \{}
\DoxyCodeLine{00143                     var currentArg = args[argIdx];}
\DoxyCodeLine{00144 }
\DoxyCodeLine{00145                     \textcolor{keywordflow}{if} (IsPlainArg(currentArg)) \textcolor{keywordflow}{break};}
\DoxyCodeLine{00146                     \textcolor{keywordflow}{if} (currentArg == \mbox{\hyperlink{classArgParser_1_1ParserBase_af32109fa88060e503c9945f4ca9d9991}{Delimiter}})}
\DoxyCodeLine{00147                     \{}
\DoxyCodeLine{00148                         argIdx++;}
\DoxyCodeLine{00149                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{00150                     \}}
\DoxyCodeLine{00151 }
\DoxyCodeLine{00152                     var option = TryGetOption(currentArg);}
\DoxyCodeLine{00153                     \textcolor{keywordflow}{if} (option == \textcolor{keyword}{null}) \textcolor{keywordflow}{throw} \textcolor{keyword}{new} ParseException(\textcolor{stringliteral}{"{}Unrecognized option"{}});}
\DoxyCodeLine{00154 }
\DoxyCodeLine{00155                     var paramCount = GetOptionParamCount(option, args, argIdx);}
\DoxyCodeLine{00156                     option.CallParse(args[(argIdx + 1)..(argIdx + paramCount + 1)]);}
\DoxyCodeLine{00157                     argIdx += paramCount + 1;}
\DoxyCodeLine{00158                 \}}
\DoxyCodeLine{00159 }
\DoxyCodeLine{00160                 \textcolor{keywordflow}{return} argIdx;}
\DoxyCodeLine{00161             \}}
\DoxyCodeLine{00162 }
\DoxyCodeLine{00163             \textcolor{keywordtype}{void} CheckPlainParamCounts(IArgument[] orderedArguments, \textcolor{keywordtype}{int} argsLength) }
\DoxyCodeLine{00164             \{}
\DoxyCodeLine{00165                 \textcolor{keywordtype}{int} min = orderedArguments}
\DoxyCodeLine{00166                    .Select(a => a.ParameterAccept.MinParamAmount)}
\DoxyCodeLine{00167                    .Aggregate(0, (acc, val) => acc + val);}
\DoxyCodeLine{00168 }
\DoxyCodeLine{00169                 \textcolor{keywordtype}{int} max = orderedArguments}
\DoxyCodeLine{00170                    .Select(a => a.ParameterAccept.MaxParamAmount)}
\DoxyCodeLine{00171                    .Aggregate(0, (acc, val) => acc + val);}
\DoxyCodeLine{00172 }
\DoxyCodeLine{00173                 \textcolor{keywordflow}{if} (argsLength < min || argsLength > max) \textcolor{keywordflow}{throw} \textcolor{keyword}{new} ParseException(\textcolor{stringliteral}{"{}arguments are incompatible"{}});}
\DoxyCodeLine{00174             \}}
\DoxyCodeLine{00175 }
\DoxyCodeLine{00176             \textcolor{keywordtype}{int} GetPlainParamCount(\textcolor{keywordtype}{int} plainArgIdx, \textcolor{keywordtype}{int} argsCount) }
\DoxyCodeLine{00177             \{}
\DoxyCodeLine{00178                 var OrderedArguments = \mbox{\hyperlink{classArgParser_1_1ParserBase_a05609e87376d6f124142ff14699a1885}{GetArgumentOrder}}();}
\DoxyCodeLine{00179                 var currentArg = OrderedArguments[plainArgIdx];}
\DoxyCodeLine{00180 }
\DoxyCodeLine{00181                 \textcolor{keywordflow}{if} (!currentArg.ParameterAccept.IsVariadic)}
\DoxyCodeLine{00182                     \textcolor{keywordflow}{return} currentArg.ParameterAccept.MinParamAmount;}
\DoxyCodeLine{00183 }
\DoxyCodeLine{00184 }
\DoxyCodeLine{00185                 var argCountRequiredByFollowingArgs = OrderedArguments[(plainArgIdx + 1)..]}
\DoxyCodeLine{00186                     .Select(a => a.ParameterAccept.MinParamAmount)}
\DoxyCodeLine{00187                     .Aggregate(0, (acc, val) => acc + val);}
\DoxyCodeLine{00188 }
\DoxyCodeLine{00189                 \textcolor{keywordflow}{return} argsCount -\/ argCountRequiredByFollowingArgs;}
\DoxyCodeLine{00190             \}}
\DoxyCodeLine{00191 }
\DoxyCodeLine{00192             \textcolor{keywordtype}{void} ParsePlainArgs(\textcolor{keywordtype}{string}[] args, \textcolor{keywordtype}{int} argIdx, IArgument[] orderedArguments) }
\DoxyCodeLine{00193             \{}
\DoxyCodeLine{00194                 \textcolor{keywordflow}{for} (var plainArgIdx = 0; plainArgIdx < orderedArguments.Length; plainArgIdx++)}
\DoxyCodeLine{00195                 \{}
\DoxyCodeLine{00196                     var remainingArgumentsCount = args.Length -\/ argIdx;}
\DoxyCodeLine{00197                     var currentArg = orderedArguments[plainArgIdx];}
\DoxyCodeLine{00198                     var valCount = GetPlainParamCount(plainArgIdx, remainingArgumentsCount);}
\DoxyCodeLine{00199 }
\DoxyCodeLine{00200                     \textcolor{keywordtype}{string}[] vals = args[argIdx..(argIdx + valCount)];}
\DoxyCodeLine{00201 }
\DoxyCodeLine{00202                     currentArg.CallParse(vals);}
\DoxyCodeLine{00203                     argIdx += valCount;}
\DoxyCodeLine{00204                 \}}
\DoxyCodeLine{00205             \}}
\DoxyCodeLine{00206 }
\DoxyCodeLine{00207             \textcolor{keywordtype}{void} CheckThatMandatoryAreParsed() }
\DoxyCodeLine{00208             \{}
\DoxyCodeLine{00209                 \textcolor{keywordflow}{foreach} (var o \textcolor{keywordflow}{in} options)}
\DoxyCodeLine{00210                 \{}
\DoxyCodeLine{00211                     \textcolor{keywordflow}{if} (o.IsMandatory \&\& !o.IsSet)}
\DoxyCodeLine{00212                         \textcolor{keywordflow}{throw} \textcolor{keyword}{new} ParseException(\textcolor{stringliteral}{"{}mandatory option not set"{}});}
\DoxyCodeLine{00213                 \}}
\DoxyCodeLine{00214             \}}
\DoxyCodeLine{00215 }
\DoxyCodeLine{00216             \textcolor{keywordtype}{int} argIdx = ParseOptions(args);}
\DoxyCodeLine{00217 }
\DoxyCodeLine{00218             var orderedArguments = \mbox{\hyperlink{classArgParser_1_1ParserBase_a05609e87376d6f124142ff14699a1885}{GetArgumentOrder}}();}
\DoxyCodeLine{00219             CheckPlainParamCounts(orderedArguments, args.Length -\/ argIdx);}
\DoxyCodeLine{00220             ParsePlainArgs(args, argIdx, orderedArguments);}
\DoxyCodeLine{00221 }
\DoxyCodeLine{00222             CheckThatMandatoryAreParsed();}
\DoxyCodeLine{00223         \}}

\end{DoxyCode}


\doxysubsection{Property Documentation}
\mbox{\Hypertarget{classArgParser_1_1ParserBase_af32109fa88060e503c9945f4ca9d9991}\label{classArgParser_1_1ParserBase_af32109fa88060e503c9945f4ca9d9991}} 
\index{ArgParser.ParserBase@{ArgParser.ParserBase}!Delimiter@{Delimiter}}
\index{Delimiter@{Delimiter}!ArgParser.ParserBase@{ArgParser.ParserBase}}
\doxysubsubsection{\texorpdfstring{Delimiter}{Delimiter}}
{\footnotesize\ttfamily virtual string Arg\+Parser.\+Parser\+Base.\+Delimiter\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [protected]}}



A command-\/line argument consisting of two dashes only, default\+: \char`\"{}-\/-\/\char`\"{}. Any subsequent argument is considered to be a plain argument 



Definition at line \mbox{\hyperlink{ParserBase_8cs_source_l00091}{91}} of file \mbox{\hyperlink{ParserBase_8cs_source}{Parser\+Base.\+cs}}.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
lib/\+Arg\+Parser/Parser\+Base.\+cs\end{DoxyCompactItemize}
